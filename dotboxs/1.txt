package main

import (
	"encoding/json"
	"fmt"
	"net"
	"time"
)

type Dab struct {
	Human         int
	Robot         int
	Record        [][]int
	TimeoutOffset float64
	Turn          int
	Now           int
}

type Robot struct {
	dab *Dab
}

func NewRobot(dab *Dab) *Robot {
	return &Robot{dab: dab}
}

func (r *Robot) RequestMove() (int32, int32, error) {
	var s0, s1 int
	s0, s1 = r.dab.Human, r.dab.Robot

	h, v := int32(0), int32(0)
	for _, move := range r.dab.Record {
		x, y := move[1], move[2]
		if move[0] == 0 {
			v |= (1 << (y*6 + x))
		} else {
			h |= (1 << (x*6 + y))
		}
	}
	algorithm := "quctann"
	timeout := uint(10+60*r.dab.TimeoutOffset) * 1000

	conn, err := net.Dial("tcp", "127.0.0.1:12345")
	if err != nil {
		return 0, 0, fmt.Errorf("error connecting: %v", err)
	}
	defer conn.Close()

	arg := map[string]interface{}{
		"method": "Server.MakeMove",
		"params": []interface{}{map[string]interface{}{
			"Algorithm": algorithm,
			"Board": map[string]interface{}{
				"H":    h,
				"V":    v,
				"S":    []int{s0, s1},
				"Now":  r.dab.Now,
				"Turn": r.dab.Turn,
			},
			"Timeout": timeout,
		}},
		"id": int(time.Now().Unix()),
	}

	data, err := json.Marshal(arg)
	if err != nil {
		return 0, 0, fmt.Errorf("error marshaling: %v", err)
	}

	_, err = conn.Write(data)
	if err != nil {
		return 0, 0, fmt.Errorf("error writing: %v", err)
	}

	buff := make([]byte, 4096) // Increased buffer size to handle larger responses
	n, err := conn.Read(buff)
	if err != nil {
		return 0, 0, fmt.Errorf("error reading: %v", err)
	}

	var res map[string]interface{}
	if err := json.Unmarshal(buff[:n], &res); err != nil {
		return 0, 0, fmt.Errorf("error unmarshaling: %v", err)
	}

	if result, ok := res["result"].(map[string]interface{}); ok {
		h, hOk := result["H"].(float64)
		v, vOk := result["V"].(float64)
		if hOk && vOk {
			return int32(h), int32(v), nil
		}
		return 0, 0, fmt.Errorf("unexpected result format: %v", result)
	} else if err, ok := res["error"].(string); ok {
		return 0, 0, fmt.Errorf("server error: %v", err)
	}
	return 0, 0, fmt.Errorf("unexpected response format: %v", res)
}

type Engine struct {
	robot *Robot
}

func NewEngine(timeoutOffset float64, record [][]int, turn, human, robot, now int) *Engine {
	dab := &Dab{
		Human:         human,
		Robot:         robot,
		Record:        record,
		TimeoutOffset: timeoutOffset,
		Turn:          turn,
		Now:           now,
	}
	return &Engine{robot: NewRobot(dab)}
}

func (e *Engine) GetNextMove() (int32, int32, error) {
	return e.robot.RequestMove()
}

func main() {
	// Example usage
	engine := NewEngine(0, [][]int{}, 1, 0, 1, 1) // Now set to 1, meaning it's Robot's turn
	h, v, err := engine.GetNextMove()
	if err != nil {
		fmt.Println("Error getting next move:", err)
		return
	}
	fmt.Printf("Received move: H=%d, V=%d\n", h, v)
}
